<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>XmlFormatAdapter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Universal Difference Checker</a> &gt; <a href="index.source.html" class="el_package">com.universaldiff.format.xml</a> &gt; <span class="el_source">XmlFormatAdapter.java</span></div><h1>XmlFormatAdapter.java</h1><pre class="source lang-java linenums">package com.universaldiff.format.xml;

import com.universaldiff.core.model.DiffFragment;
import com.universaldiff.core.model.DiffHunk;
import com.universaldiff.core.model.DiffResult;
import com.universaldiff.core.model.DiffSide;
import com.universaldiff.core.model.DiffType;
import com.universaldiff.core.model.FileDescriptor;
import com.universaldiff.core.model.FormatType;
import com.universaldiff.core.model.MergeChoice;
import com.universaldiff.core.model.MergeDecision;
import com.universaldiff.core.model.MergeResult;
import com.universaldiff.core.model.NormalizedContent;
import com.universaldiff.format.spi.FormatAdapter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

<span class="fc" id="L49">public class XmlFormatAdapter implements FormatAdapter {</span>

<span class="fc" id="L51">    private static final Logger log = LoggerFactory.getLogger(XmlFormatAdapter.class);</span>

    @Override
    public NormalizedContent normalize(FileDescriptor descriptor) throws IOException {
<span class="fc" id="L55">        Document document = parse(descriptor.getPath());</span>
<span class="fc" id="L56">        Map&lt;String, String&gt; flattened = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L57">        flatten(document.getDocumentElement(), &quot;/&quot; + document.getDocumentElement().getNodeName() + &quot;[1]&quot;, flattened);</span>
<span class="fc" id="L58">        List&lt;String&gt; logical = flattened.entrySet().stream()</span>
<span class="fc" id="L59">                .map(e -&gt; e.getKey() + &quot; = &quot; + e.getValue())</span>
<span class="fc" id="L60">                .toList();</span>
<span class="fc" id="L61">        return NormalizedContent.builder(FormatType.XML)</span>
<span class="fc" id="L62">                .logicalRecords(logical)</span>
<span class="fc" id="L63">                .nativeModel(document)</span>
<span class="fc" id="L64">                .encoding(descriptor.getEncoding())</span>
<span class="fc" id="L65">                .build();</span>
    }

    private Document parse(Path path) throws IOException {
<span class="fc" id="L69">        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span>
<span class="fc" id="L70">        factory.setNamespaceAware(true);</span>
        try {
<span class="fc" id="L72">            factory.setFeature(&quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;, false);</span>
<span class="pc" id="L73">        } catch (ParserConfigurationException ex) {</span>
<span class="nc" id="L74">            throw new XmlProcessingException(&quot;XML parser configuration error&quot;, ex);</span>
        }
<span class="fc" id="L76">        try (InputStream in = Files.newInputStream(path)) {</span>
<span class="fc" id="L77">            DocumentBuilder builder = factory.newDocumentBuilder();</span>
<span class="fc" id="L78">            return builder.parse(in);</span>
<span class="fc" id="L79">        } catch (ParserConfigurationException ex) {</span>
<span class="fc" id="L80">            throw new XmlProcessingException(&quot;XML parser configuration error&quot;, ex);</span>
<span class="fc" id="L81">        } catch (org.xml.sax.SAXParseException ex) {</span>
<span class="fc" id="L82">            throw new XmlProcessingException(&quot;Malformed XML at line &quot; + ex.getLineNumber()</span>
<span class="fc" id="L83">                    + &quot;, column &quot; + ex.getColumnNumber() + &quot;: &quot; + ex.getMessage(), ex);</span>
<span class="nc" id="L84">        } catch (org.xml.sax.SAXException ex) {</span>
<span class="nc" id="L85">            throw new XmlProcessingException(&quot;Malformed XML content in &quot; + path, ex);</span>
<span class="nc" id="L86">        } catch (IOException ex) {</span>
<span class="nc" id="L87">            throw new XmlProcessingException(&quot;I/O error while reading XML from &quot; + path, ex);</span>
        }
    }

    private void flatten(Node node, String path, Map&lt;String, String&gt; result) {
<span class="pc bpc" id="L92" title="1 of 2 branches missed.">        if (node == null) {</span>
<span class="nc" id="L93">            return;</span>
        }
<span class="fc bfc" id="L95" title="All 2 branches covered.">        if (node.hasAttributes()) {</span>
<span class="fc" id="L96">            NamedNodeMap attrs = node.getAttributes();</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">            for (int i = 0; i &lt; attrs.getLength(); i++) {</span>
<span class="fc" id="L98">                Attr attr = (Attr) attrs.item(i);</span>
<span class="fc" id="L99">                result.put(path + &quot;/@&quot; + attr.getName(), attr.getValue());</span>
            }
        }
<span class="fc" id="L102">        NodeList children = node.getChildNodes();</span>
<span class="fc" id="L103">        Map&lt;String, Integer&gt; counters = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L104">        boolean hasElementChildren = false;</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">        for (int i = 0; i &lt; children.getLength(); i++) {</span>
<span class="fc" id="L106">            Node child = children.item(i);</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">            if (child.getNodeType() == Node.ELEMENT_NODE) {</span>
<span class="fc" id="L108">                hasElementChildren = true;</span>
<span class="fc" id="L109">                String name = child.getNodeName();</span>
<span class="fc" id="L110">                int index = counters.getOrDefault(name, 0) + 1;</span>
<span class="fc" id="L111">                counters.put(name, index);</span>
<span class="fc" id="L112">                flatten(child, path + &quot;/&quot; + name + &quot;[&quot; + index + &quot;]&quot;, result);</span>
            }
        }
<span class="fc bfc" id="L115" title="All 2 branches covered.">        if (!hasElementChildren) {</span>
<span class="fc" id="L116">            String text = node.getTextContent().trim();</span>
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">            if (!text.isEmpty()) {</span>
<span class="fc" id="L118">                result.put(path + &quot;/text()&quot;, text);</span>
            }
        }
<span class="fc" id="L121">    }</span>

    @Override
    public DiffResult diff(NormalizedContent left, NormalizedContent right) {
<span class="fc" id="L125">        Instant start = Instant.now();</span>
<span class="fc" id="L126">        Map&lt;String, String&gt; leftMap = toMap(left);</span>
<span class="fc" id="L127">        Map&lt;String, String&gt; rightMap = toMap(right);</span>
<span class="fc" id="L128">        List&lt;DiffHunk&gt; hunks = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">        for (String path : leftMap.keySet()) {</span>
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">            if (!rightMap.containsKey(path)) {</span>
<span class="nc" id="L131">                hunks.add(DiffHunk.of(</span>
<span class="nc" id="L132">                        &quot;xml-path-&quot; + encode(path),</span>
<span class="nc" id="L133">                        DiffType.DELETE,</span>
<span class="nc" id="L134">                        path,</span>
<span class="nc" id="L135">                        List.of(new DiffFragment(DiffSide.LEFT, 0, 0, leftMap.get(path)))));</span>
<span class="pc bfc" id="L136" title="All 2 branches covered.">            } else if (!leftMap.get(path).equals(rightMap.get(path))) {</span>
<span class="fc" id="L137">                hunks.add(DiffHunk.of(</span>
<span class="fc" id="L138">                        &quot;xml-path-&quot; + encode(path),</span>
<span class="fc" id="L139">                        DiffType.MODIFY,</span>
<span class="fc" id="L140">                        path,</span>
<span class="fc" id="L141">                        List.of(</span>
<span class="fc" id="L142">                                new DiffFragment(DiffSide.LEFT, 0, 0, leftMap.get(path)),</span>
<span class="fc" id="L143">                                new DiffFragment(DiffSide.RIGHT, 0, 0, rightMap.get(path))</span>
                        )));
            }
        }
<span class="fc bfc" id="L147" title="All 2 branches covered.">        for (String path : rightMap.keySet()) {</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">            if (!leftMap.containsKey(path)) {</span>
<span class="fc" id="L149">                hunks.add(DiffHunk.of(</span>
<span class="fc" id="L150">                        &quot;xml-path-&quot; + encode(path),</span>
<span class="fc" id="L151">                        DiffType.INSERT,</span>
<span class="fc" id="L152">                        path,</span>
<span class="fc" id="L153">                        List.of(new DiffFragment(DiffSide.RIGHT, 0, 0, rightMap.get(path)))));</span>
            }
        }
<span class="fc" id="L156">        return new DiffResult(FormatType.XML, hunks, Duration.between(start, Instant.now()));</span>
    }

    private String encode(String path) {
<span class="fc" id="L160">        return java.util.Base64.getEncoder().encodeToString(path.getBytes());</span>
    }

    private String decode(String encoded) {
<span class="fc" id="L164">        return new String(java.util.Base64.getDecoder().decode(encoded));</span>
    }

    private Map&lt;String, String&gt; toMap(NormalizedContent content) {
<span class="fc" id="L168">        Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;();</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">        for (String record : content.getLogicalRecords()) {</span>
<span class="fc" id="L170">            int sep = record.indexOf(&quot; = &quot;);</span>
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">            if (sep &gt; 0) {</span>
<span class="fc" id="L172">                map.put(record.substring(0, sep), record.substring(sep + 3));</span>
            }
        }
<span class="fc" id="L175">        return map;</span>
    }

    @Override
    public MergeResult merge(NormalizedContent left,
                             NormalizedContent right,
                             List&lt;MergeDecision&gt; decisions,
                             Path outputPath) throws IOException {
<span class="fc" id="L183">        Instant start = Instant.now();</span>
<span class="fc" id="L184">        Document leftDoc = ((Document) left.getNativeModel());</span>
<span class="fc" id="L185">        Document merged = (Document) leftDoc.cloneNode(true);</span>
<span class="fc" id="L186">        Document rightDoc = ((Document) right.getNativeModel());</span>
<span class="fc" id="L187">        XPath xpath = XPathFactory.newInstance().newXPath();</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">        for (MergeDecision decision : decisions) {</span>
<span class="fc" id="L189">            String encoded = decision.getHunkId().replace(&quot;xml-path-&quot;, &quot;&quot;);</span>
<span class="fc" id="L190">            String path = decode(encoded);</span>
<span class="pc bpc" id="L191" title="2 of 4 branches missed.">            switch (decision.getChoice()) {</span>
                case TAKE_LEFT -&gt; {
                    // no-op
                }
<span class="fc" id="L195">                case TAKE_RIGHT -&gt; applyFromRight(merged, rightDoc, xpath, path);</span>
                case MANUAL -&gt; {
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">                    if (decision.getManualContent() != null) {</span>
<span class="fc" id="L198">                        applyManual(merged, xpath, path, decision.getManualContent());</span>
                    }
                }
            }
        }
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">        if (outputPath != null) {</span>
<span class="fc" id="L204">            Files.writeString(outputPath, serialize(merged), left.getEncoding());</span>
        }
<span class="fc" id="L206">        return new MergeResult(FormatType.XML, outputPath, Duration.between(start, Instant.now()));</span>
    }

    private void applyFromRight(Document target, Document source, XPath xpath, String path) throws IOException {
        try {
<span class="fc" id="L211">            Node sourceNode = (Node) xpath.evaluate(path, source, XPathConstants.NODE);</span>
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">            if (sourceNode == null) {</span>
<span class="nc" id="L213">                return;</span>
            }
<span class="fc bfc" id="L215" title="All 2 branches covered.">            if (path.endsWith(&quot;/text()&quot;)) {</span>
<span class="fc" id="L216">                Node targetNode = (Node) xpath.evaluate(parentPath(path), target, XPathConstants.NODE);</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">                if (targetNode != null) {</span>
<span class="fc" id="L218">                    targetNode.setTextContent(sourceNode.getNodeValue());</span>
                }
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">            } else if (path.contains(&quot;/@&quot;)) {</span>
<span class="fc" id="L221">                Node targetNode = (Node) xpath.evaluate(path, target, XPathConstants.NODE);</span>
<span class="pc bpc" id="L222" title="2 of 4 branches missed.">                if (targetNode != null &amp;&amp; targetNode.getNodeType() == Node.ATTRIBUTE_NODE) {</span>
<span class="fc" id="L223">                    targetNode.setNodeValue(sourceNode.getNodeValue());</span>
                }
<span class="fc" id="L225">            } else {</span>
<span class="nc" id="L226">                Node targetNode = (Node) xpath.evaluate(path, target, XPathConstants.NODE);</span>
<span class="nc bnc" id="L227" title="All 4 branches missed.">                if (targetNode != null &amp;&amp; targetNode.getParentNode() != null) {</span>
<span class="nc" id="L228">                    Node imported = target.importNode(sourceNode, true);</span>
<span class="nc" id="L229">                    targetNode.getParentNode().replaceChild(imported, targetNode);</span>
                }
            }
<span class="nc" id="L232">        } catch (XPathExpressionException ex) {</span>
<span class="nc" id="L233">            log.debug(&quot;XPath evaluation failed for path '{}' during merge&quot;, path, ex);</span>
<span class="nc" id="L234">            throw new XmlProcessingException(&quot;Failed to apply XML merge for path &quot; + path, ex);</span>
        }
<span class="fc" id="L236">    }</span>

    private void applyManual(Document target, XPath xpath, String path, String value) throws IOException {
        try {
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">            if (path.endsWith(&quot;/text()&quot;)) {</span>
<span class="fc" id="L241">                Node node = (Node) xpath.evaluate(parentPath(path), target, XPathConstants.NODE);</span>
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">                if (node != null) {</span>
<span class="fc" id="L243">                    node.setTextContent(value);</span>
                }
<span class="pc bnc" id="L245" title="All 2 branches missed.">            } else if (path.contains(&quot;/@&quot;)) {</span>
<span class="nc" id="L246">                Node node = (Node) xpath.evaluate(path, target, XPathConstants.NODE);</span>
<span class="nc bnc" id="L247" title="All 4 branches missed.">                if (node != null &amp;&amp; node.getNodeType() == Node.ATTRIBUTE_NODE) {</span>
<span class="nc" id="L248">                    node.setNodeValue(value);</span>
                }
            }
<span class="nc" id="L251">        } catch (XPathExpressionException ex) {</span>
<span class="nc" id="L252">            log.debug(&quot;XPath evaluation failed for manual content at path '{}'&quot;, path, ex);</span>
<span class="nc" id="L253">            throw new XmlProcessingException(&quot;Failed to apply manual XML content for path &quot; + path, ex);</span>
        }
<span class="fc" id="L255">    }</span>

    private String parentPath(String path) {
<span class="fc" id="L258">        int idx = path.lastIndexOf('/');</span>
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">        if (idx &lt;= 0) {</span>
<span class="nc" id="L260">            return path;</span>
        }
<span class="fc" id="L262">        return path.substring(0, idx);</span>
    }

    private String serialize(Document document) throws IOException {
        try {
<span class="fc" id="L267">            Transformer transformer = TransformerFactory.newInstance().newTransformer();</span>
<span class="fc" id="L268">            transformer.setOutputProperty(OutputKeys.INDENT, &quot;yes&quot;);</span>
<span class="fc" id="L269">            transformer.setOutputProperty(&quot;{http://xml.apache.org/xslt}indent-amount&quot;, &quot;2&quot;);</span>
<span class="fc" id="L270">            StringWriter writer = new StringWriter();</span>
<span class="fc" id="L271">            transformer.transform(new DOMSource(document), new StreamResult(writer));</span>
<span class="fc" id="L272">            return writer.toString();</span>
<span class="nc" id="L273">        } catch (TransformerException ex) {</span>
<span class="nc" id="L274">            throw new XmlProcessingException(&quot;Failed to serialize XML document&quot;, ex);</span>
        }
    }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>
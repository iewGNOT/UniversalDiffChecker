<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JacksonTreeJsonNormalizer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Universal Difference Checker</a> &gt; <a href="index.source.html" class="el_package">com.universaldiff.format.json</a> &gt; <span class="el_source">JacksonTreeJsonNormalizer.java</span></div><h1>JacksonTreeJsonNormalizer.java</h1><pre class="source lang-java linenums">package com.universaldiff.format.json;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.universaldiff.core.model.FileDescriptor;
import com.universaldiff.core.model.FormatType;
import com.universaldiff.core.model.NormalizedContent;
import com.universaldiff.format.json.spi.JsonNormalizer;

import java.io.IOException;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

/**
 * Default {@link JsonNormalizer} that leverages Jackson's tree model and a deterministic flattening pass.
 * Diff adapters rely on the flattened map for stable comparisons regardless of object field order.
 */
final class JacksonTreeJsonNormalizer implements JsonNormalizer {

    private final ObjectMapper mapper;
    private final boolean ignoreKeyOrder;

<span class="fc" id="L26">    JacksonTreeJsonNormalizer(ObjectMapper mapper, boolean ignoreKeyOrder) {</span>
<span class="fc" id="L27">        this.mapper = mapper;</span>
<span class="fc" id="L28">        this.ignoreKeyOrder = ignoreKeyOrder;</span>
<span class="fc" id="L29">    }</span>

    @Override
    public NormalizedContent normalize(FileDescriptor descriptor) throws IOException {
<span class="fc" id="L33">        String raw = Files.readString(descriptor.getPath(), descriptor.getEncoding());</span>
<span class="fc" id="L34">        JsonNode root = mapper.readTree(raw);</span>
<span class="fc" id="L35">        Map&lt;String, String&gt; flattened = new TreeMap&lt;&gt;();</span>
<span class="fc" id="L36">        flatten(&quot;&quot;, root, flattened);</span>
<span class="fc" id="L37">        List&lt;String&gt; logical = flattened.entrySet().stream()</span>
<span class="fc" id="L38">                .map(e -&gt; e.getKey() + &quot; = &quot; + e.getValue())</span>
<span class="fc" id="L39">                .toList();</span>
<span class="fc" id="L40">        return NormalizedContent.builder(FormatType.JSON)</span>
<span class="fc" id="L41">                .logicalRecords(logical)</span>
<span class="fc" id="L42">                .nativeModel(root)</span>
<span class="fc" id="L43">                .encoding(descriptor.getEncoding())</span>
<span class="fc" id="L44">                .build();</span>
    }

    private void flatten(String path, JsonNode node, Map&lt;String, String&gt; result) {
<span class="pc bpc" id="L48" title="1 of 2 branches missed.">        if (node == null) {</span>
<span class="nc" id="L49">            result.put(path, &quot;null&quot;);</span>
<span class="nc" id="L50">            return;</span>
        }
<span class="fc bfc" id="L52" title="All 2 branches covered.">        if (node.isValueNode()) {</span>
<span class="fc" id="L53">            result.put(path, mapper.convertValue(node, String.class));</span>
<span class="fc" id="L54">            return;</span>
        }
<span class="fc bfc" id="L56" title="All 2 branches covered.">        if (node.isArray()) {</span>
<span class="fc bfc" id="L57" title="All 2 branches covered.">            for (int i = 0; i &lt; node.size(); i++) {</span>
<span class="fc" id="L58">                flatten(path + &quot;/&quot; + i, node.get(i), result);</span>
            }
<span class="fc" id="L60">            return;</span>
        }
<span class="pc bpc" id="L62" title="1 of 2 branches missed.">        if (node.isObject()) {</span>
<span class="fc" id="L63">            List&lt;String&gt; fieldNames = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L64">            node.fieldNames().forEachRemaining(fieldNames::add);</span>
<span class="fc bfc" id="L65" title="All 2 branches covered.">            if (ignoreKeyOrder) {</span>
<span class="fc" id="L66">                fieldNames.sort(String::compareTo);</span>
            }
<span class="fc bfc" id="L68" title="All 2 branches covered.">            for (String field : fieldNames) {</span>
<span class="fc" id="L69">                flatten(path + &quot;/&quot; + escape(field), node.get(field), result);</span>
            }
        }
<span class="fc" id="L72">    }</span>

    private String escape(String token) {
<span class="fc" id="L75">        return token.replace(&quot;~&quot;, &quot;~0&quot;).replace(&quot;/&quot;, &quot;~1&quot;);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>